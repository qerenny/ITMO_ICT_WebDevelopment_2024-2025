<!doctype html>
<html>
    <head>
                <title>Task 5 - just_place</title>

            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">

            
            
            

            
                <link  rel="icon" type="image/x-icon" href="../assets/img/favicon.ico">
            
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                        <script>hljs.initHighlightingOnLoad();</script>
            <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700">
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../assets/css/bootstrap.min.css">
            <link rel="stylesheet" href="../assets/css/main.min.css">
                <script src="../search/main.js"></script>

            
                
            
    </head>

    <body>
        <div class="container py-3">
            <header>
                    <!-- block header -->
<nav class="navbar navbar-expand-xl border-bottom">
    <div class="container-fluid">
        

        
            <span class=" fs-4 title-color site-name" id="component-site-name" style="text-transform: uppercase;">just_place</span>
        

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
            aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
            <ul class="navbar-nav">

                <!-- block menu -->
                <li class="nav-item">
                    <!-- block menu -->
    
        <li class="nav-item" id="component-menu">
            <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="
                            nav-link text-gray text-decoration-none" href="..">[Home]</a>
                        </li>
                        <li class="nav-item">
                            <a class="
                            nav-link text-gray text-decoration-none" href="../task1/">[Task 1]</a>
                        </li>
                        <li class="nav-item">
                            <a class="
                            nav-link text-gray text-decoration-none" href="../task2/">[Task 2]</a>
                        </li>
                        <li class="nav-item">
                            <a class="
                            nav-link text-gray text-decoration-none" href="../task3/">[Task 3]</a>
                        </li>
                        <li class="nav-item">
                            <a class="
                            nav-link text-gray text-decoration-none" href="../task4/">[Task 4]</a>
                        </li>
                        <li class="nav-item">
                            <a class=" active 
                            nav-link text-gray text-decoration-none" href="./">[Task 5]</a>
                        </li>
            </ul>
        </li>
<!-- endblock -->
                </li>
                <!-- endblock -->

                <!-- block search -->
                <li class="nav-item">
                    <a class="collapsed" data-bs-toggle="collapse" href="#collapseExample" role="button" aria-expanded="false" aria-controls="collapseExample">
                        <div class="md-search-icon">
                            <i class="fa fa-search" aria-hidden="true"></i>
                        </div>
                    </a>
                </li>
                <!--  endblock -->

                <!-- block source -->
                <li class="nav-item">
                    
                </li>
                <!--  endblock -->
            </ul>
        </div>
    </div>
</nav>
<!--  endblock -->
            </header>

            <main><!-- block search -->
<div class="collapse" id="collapseExample">
    <div role="search" class="search-box">
        <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
            <input type="text" name="q" class="search-query"
            placeholder="Search docs" title="Type search term here" />
        </form>
    </div>
</div>
<!-- endblock -->
                    <!-- block content -->
<section class="container post">
    <article>
        <header>
            
                <h1 class=" title" id="component-title">Task 5</h1>
            
        </header>
        <p><h1 id="-get-post-http-">Реализация простого веб-сервера для обработки GET и POST HTTP-запросов</h1>
<h2 id="_1">Условие</h2>
<p><strong>Задача</strong>: Написать простой веб-сервер для обработки GET и POST HTTP-запросов с помощью библиотеки <code>socket</code> в Python. Сервер должен выполнять следующие функции:
1. Принимать и записывать информацию о дисциплине и оценке по дисциплине.
2. Отдавать информацию обо всех оценках по дисциплинам в виде HTML-страницы.</p>
<h2 id="_2">Решение</h2>
<p>В рамках задания был реализован простой веб-сервер, который обрабатывает запросы и управляет информацией о дисциплинах и оценках. Основные функции сервера включают добавление новых дисциплин и оценок, а также предоставление информации о всех оценках в виде HTML-страницы и JSON формате.</p>
<h3 id="_3">Основные классы</h3>
<ol>
<li>
<p><strong>Класс <code>MyHTTPServer</code></strong>: Основной класс, реализующий работу веб-сервера. Он управляет подключениями клиентов, обрабатывает запросы и отправляет ответы.</p>
</li>
<li>
<p><strong>Класс <code>Request</code></strong>: Представляет HTTP-запрос и предоставляет методы для доступа к методу запроса, пути, заголовкам и параметрам запроса.</p>
</li>
<li>
<p><strong>Класс <code>Response</code></strong>: Представляет HTTP-ответ, который сервер отправляет клиенту. Содержит статус, описание, заголовки и тело ответа.</p>
</li>
<li>
<p><strong>Класс <code>HTTPError</code></strong>: Используется для представления ошибок HTTP и формирования соответствующих ответов с ошибками.</p>
</li>
</ol>
<h3 id="_4">Основные функции</h3>
<ol>
<li>
<p><strong><code>serve_forever</code></strong>:</p>
<blockquote>
<p>Запускает сервер, который ожидает подключения клиентов.
Принимает клиентские подключения и передает их для обработки в метод <code>serve_client</code>.</p>
</blockquote>
</li>
<li>
<p><strong><code>serve_client</code></strong>:</p>
<blockquote>
<p>Обрабатывает запрос клиента, включая разбор запроса, обработку и отправку ответа.
В случае ошибки отправляет соответствующий ответ об ошибке.</p>
</blockquote>
</li>
<li>
<p><strong><code>parse_request</code></strong>:</p>
<blockquote>
<p>Разбирает запрос клиента, извлекая метод, путь, версию HTTP и заголовки.
Проверяет корректность заголовка <code>Host</code>.</p>
</blockquote>
</li>
<li>
<p><strong><code>handle_request</code></strong>:</p>
<blockquote>
<p>Определяет тип запроса (POST или GET) и передает его в соответствующую функцию для обработки:
<code>handle_post_subject</code> для добавления новой дисциплины.
<code>handle_get_subjects</code> для получения списка дисциплин.
<code>handle_get_marks</code> для получения оценок по дисциплине. 
<code>handle_add_mark</code> для добавления оценки по дисциплине.</p>
</blockquote>
</li>
<li>
<p><strong><code>handle_post_subject</code></strong>:</p>
<blockquote>
<p>Добавляет новую дисциплину в базу данных сервера.
Дисциплина идентифицируется по уникальному ID и хранится вместе с пустым списком оценок.</p>
</blockquote>
</li>
<li>
<p><strong><code>handle_get_subjects</code></strong>:</p>
<blockquote>
<p>Возвращает список всех дисциплин в зависимости от типа запрашиваемого контента (<code>text/html</code> или <code>application/json</code>).
Если запрашивается HTML, генерируется HTML-страница со списком дисциплин или JSON.</p>
</blockquote>
</li>
<li>
<p><strong><code>handle_get_marks</code></strong>:</p>
<blockquote>
<p>Возвращает оценки по заданной дисциплине в формате HTML или JSON.
Генерирует HTML-страницу, если запрашивается HTML, или возвращает JSON-данные.</p>
</blockquote>
</li>
<li>
<p><strong><code>handle_add_mark</code></strong>:</p>
<blockquote>
<p>Добавляет оценку к заданной дисциплине.
Проверяет корректность значения оценки (должна быть в диапазоне от 0 до 100).</p>
</blockquote>
</li>
<li>
<p><strong><code>send_response</code></strong>:</p>
<blockquote>
<p>Отправляет HTTP-ответ клиенту.
Формирует статусную строку, заголовки и тело ответа.</p>
</blockquote>
</li>
<li>
<p><strong><code>send_error</code></strong>:</p>
<blockquote>
<p>Отправляет ответ об ошибке в случае возникновения исключений.</p>
</blockquote>
</li>
</ol>
<h3 id="_5">Пример работы</h3>
<ol>
<li><strong>Добавление новой дисциплины</strong>:<blockquote>
<p>Клиент отправляет POST-запрос на <code>/subjects</code> с параметрами <code>name</code> (название дисциплины). 
Сервер добавляет дисциплину и возвращает ответ.</p>
</blockquote>
</li>
<li><strong>Получение списка дисциплин</strong>:<blockquote>
<p>Клиент отправляет GET-запрос на <code>/subjects</code>.
Сервер возвращает список дисциплин в виде HTML или JSON в зависимости от заголовка <code>Accept</code>.</p>
</blockquote>
</li>
<li><strong>Добавление оценки по дисциплине</strong>:<blockquote>
<p>Клиент отправляет POST-запрос на <code>/subjects/{subject_id}</code> с параметром <code>mark</code> (оценка).
Сервер добавляет оценку и возвращает ответ.</p>
</blockquote>
</li>
<li><strong>Получение оценок по дисциплине</strong>:    <blockquote>
<p>Клиент отправляет GET-запрос на <code>/subjects/{subject_id}</code>.
Сервер возвращает оценки в формате HTML или JSON в зависимости от заголовка <code>Accept</code>.</p>
</blockquote>
</li>
</ol>
<h2 id="_6">Код</h2>
<pre><code class="language-python">import socket
import json
from email.parser import Parser
from urllib.parse import parse_qs, urlparse
from functools import lru_cache

MAX_LINE = 64 * 1024
MAX_HEADERS = 100

class MyHTTPServer:
    def __init__(self, host, port, server_name):
        self._host = host
        self._port = port
        self._server_name = server_name
        self._subjects = {}

    def serve_forever(self):
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto=0)
        try:
            server_socket.bind((self._host, self._port))
            server_socket.listen()
            while True:
                client_socket, _ = server_socket.accept()
                try:
                    self.serve_client(client_socket)
                except Exception as e:
                    print('Client serving failed:', e)
        finally:
            server_socket.close()

    def serve_client(self, client_socket):
        try:
            request = self.parse_request(client_socket)
            response = self.handle_request(request)
            self.send_response(client_socket, response)
        except ConnectionResetError:
            client_socket = None
        except Exception as e:
            self.send_error(client_socket, e)

        if client_socket:
            client_socket.close()

    def parse_request(self, client_socket):
        rfile = client_socket.makefile('rb')
        method, target, version = self.parse_request_line(rfile)
        headers = self.parse_headers(rfile)

        host = headers.get('Host')
        if not host:
            raise HTTPError(400, 'Bad request', 'Host header is missing')
        if host not in (self._server_name, f'{self._server_name}:{self._port}'):
            raise HTTPError(404, 'Not found')

        print(method, target, version, headers)
        return Request(method, target, version, headers, rfile)

    def parse_request_line(self, file):
        line = file.readline(MAX_LINE + 1)
        if len(line) &gt; MAX_LINE:
            raise HTTPError(400, 'Bad request', 'Request line is too long')

        req_line = str(line, &quot;iso-8859-1&quot;)
        req_line = req_line.rstrip(&quot;\r\n&quot;)
        words = req_line.split()
        if len(words) != 3:
            raise HTTPError(400, 'Bad request', 'Malformed request line')

        method, target, version = words
        if version != &quot;HTTP/1.1&quot;:
            raise HTTPError(505, 'HTTP Version Not Supported')

        return method, target, version

    def parse_headers(self, file):
        headers = []
        while True:
            line = file.readline(MAX_LINE + 1)
            if len(line) &gt; MAX_LINE:
                raise HTTPError(494, 'Request header too large')
            if line in (b&quot;\r\n&quot;, b&quot;\n&quot;, b&quot;&quot;):
                break
            headers.append(line)
            if len(headers) &gt; MAX_HEADERS:
                raise HTTPError(494, 'Too many headers')

        sheaders = b&quot;&quot;.join(headers).decode('iso-8859-1')
        return Parser().parsestr(sheaders)

    def handle_request(self, req):
        if req.path == '/subjects' and req.method == 'POST':
            return self.handle_post_subject(req)

        if req.path == '/subjects' and req.method == 'GET':
            return self.handle_get_subjects(req)

        if req.path.startswith('/subjects/'):
            subject_id = req.path[len('/subjects/'):]
            if req.method == 'GET':
                return self.handle_get_marks(req, subject_id)
            if req.method == 'POST':
                return self.handle_add_mark(req, subject_id)

        raise HTTPError(404, 'Not found')

    def handle_post_subject(self, req):
        subject_id = len(self._subjects) + 1
        self._subjects[subject_id] = {
            'id': subject_id,
            'name': req.query['name'][0],
            'mark': [],
        }
        return Response(204, 'Created')

    def handle_get_subjects(self, req):
        accept = req.headers.get('Accept')

        if 'text/html' in accept:
            content_type = 'text/html; charset=utf-8'
            body = self._generate_html_subjects_body()
        elif 'application/json' in accept:
            content_type = 'application/json; charset=utf-8'
            body = json.dumps(list(self._subjects.values())).encode('utf-8')
        else:
            return Response(406, 'Not Acceptable')

        headers = [
            ('Content-Type', content_type),
            ('Content-Length', str(len(body)))
        ]
        return Response(200, 'OK', headers, body)

    def _generate_html_subjects_body(self):
        subjects_list = ''.join(
            f'&lt;li&gt;{subj[&quot;id&quot;]}: {subj[&quot;name&quot;]}&lt;/li&gt;'
            for subj in self._subjects.values()
        )
        html = f'''
        &lt;html&gt;
          &lt;head&gt;&lt;title&gt;Subjects&lt;/title&gt;&lt;/head&gt;
          &lt;body&gt;
            &lt;ul&gt;{subjects_list}&lt;/ul&gt;
          &lt;/body&gt;
        &lt;/html&gt;
        '''
        return html.strip().encode('utf-8')
    def handle_get_marks(self, req, subject_id):
        try:
            subject_id = int(subject_id)
            subject = self._subjects.get(subject_id)
            if not subject:
                raise HTTPError(404, 'Subject not found')

            accept = req.headers.get('Accept', '')
            if 'text/html' in accept:
                content_type = 'text/html; charset=utf-8'
                body = self._generate_html_marks_body(subject)
            elif 'application/json' in accept:
                content_type = 'application/json; charset=utf-8'
                body = json.dumps(subject).encode('utf-8')
            else:
                return Response(406, 'Not Acceptable')

            headers = [
                ('Content-Type', content_type),
                ('Content-Length', str(len(body)))
            ]
            return Response(200, 'OK', headers, body)
        except ValueError:
            raise HTTPError(400, 'Invalid subject ID')

    def _generate_html_marks_body(self, subject):
        marks_list = ''.join(f'&lt;li&gt;{mark}&lt;/li&gt;' for mark in subject['mark'])
        html = f'''
        &lt;html&gt;
          &lt;head&gt;&lt;title&gt;Marks for {subject[&quot;name&quot;]}&lt;/title&gt;&lt;/head&gt;
          &lt;body&gt;
            &lt;h1&gt;Marks for {subject[&quot;name&quot;]}&lt;/h1&gt;
            &lt;ul&gt;{marks_list}&lt;/ul&gt;
          &lt;/body&gt;
        &lt;/html&gt;
        '''
        return html.strip().encode('utf-8')

    def handle_add_mark(self, req, subject_id):
        try:
            subject_id = int(subject_id)
            subject = self._subjects.get(subject_id)
            if not subject:
                raise HTTPError(404, 'Subject not found')

            if 'mark' not in req.query:
                raise HTTPError(400, 'Mark is required')

            mark = req.query['mark'][0]
            try:
                mark = float(mark)
                if not (0 &lt;= mark &lt;= 100):
                    raise ValueError
            except ValueError:
                raise HTTPError(400, 'Invalid mark value')

            subject['mark'].append(mark)

            return Response(204, 'Mark added')
        except ValueError:
            raise HTTPError(400, 'Invalid subject ID')
    def send_response(self, conn, resp):
        wfile = conn.makefile('wb')
        status_line = f'HTTP/1.1 {resp.status} {resp.reason}\r\n'
        wfile.write(status_line.encode('iso-8859-1'))

        if resp.headers:
            for key, value in resp.headers:
                header_line = f&quot;{key}: {value}\r\n&quot;
                wfile.write(header_line.encode(&quot;iso-8859-1&quot;))

        wfile.write(b&quot;\r\n&quot;)
        if resp.body:
            wfile.write(resp.body)

        wfile.flush()
        wfile.close()

    def send_error(self, conn, err):
        try:
            status = err.status
            reason = err.reason
            body = (err.body or err.reason).encode('utf-8')
        except:
            status = 500
            reason = 'Internal Server Error'
            body = 'Internal Server Error'.encode('utf-8')

        resp = Response(status, reason, [('Content-Length', len(body))], body)
        self.send_response(conn, resp)


class Request:
    def __init__(self, method, target, version, headers, rfile):
        self.method = method
        self.target = target
        self.version = version
        self.headers = headers
        self.rfile = rfile

    @property
    def path(self):
        return self.url.path

    @property
    @lru_cache(maxsize=None)
    def query(self):
        return parse_qs(self.url.query)

    @property
    @lru_cache(maxsize=None)
    def url(self):
        return urlparse(self.target)


class Response:
    def __init__(self, status, reason, headers=None, body=None):
        self.status = status
        self.reason = reason
        self.headers = headers
        self.body = body


class HTTPError(Exception):
    def __init__(self, status, reason, body=None):
        super().__init__()
        self.status = status
        self.reason = reason
        self.body = body


if __name__ == '__main__':
    host = '127.0.0.1'
    port = 12345
    server_name = 'example.local'
    server = MyHTTPServer(host, port, server_name)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
</code></pre></p>
    </article>
</section>
<!-- endblock -->
            </main>

            
                    <!-- block preview -->
        <div class="row row-cols-md-3 text-center pt-md-3" id="component-preview">
            <div class="col themed-grid-col">
                <a rel="prev" href="../task4/" class="nav-link">
                    <i class="fa fa-arrow-left"></i> Previous
                </a>
            </div>
            <div class="col themed-grid-col"></div>
            <div class="col themed-grid-col">
                <a rel="next" class="nav-link disabled">
                    Next <i class="fa fa-arrow-right"></i>
                </a>
            </div>
        </div>
<!-- endblock -->
            

            
                    <!-- block footer -->
<footer class="pt-4 my-md-5 pt-md-5 border-top" id="component-footer">
    <div class="row">
        <div class="col-12 col-md">
                <!-- block copyright -->

    <small class="d-block mb-3">
        Made with
        <a href="https://github.com/FernandoCelmer/mkdocs-simple-blog" target="_blank" rel="noopener">
            Simple Blog for MkDocs
        </a>
    </small>

<!-- endblock -->
        </div>
    </div>
</footer>
<!-- endblock -->
            
        </div>

            <script>var base_url = '..';</script>
            <script src="../assets/js/jquery-3.3.1.slim.min.js""></script>
            <script src="../assets/js/bootstrap.bundle.min.js""></script>
            <script src="../assets/js/main.min.js""></script>
                <script src="../search/main.js" defer></script>

    </body>

</html>